import{_ as p,o as e,c as l,O as t}from"./chunks/framework.95b9d657.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"moment_src/必背题_js.md","filePath":"moment_src/必背题_js.md"}'),a={name:"moment_src/必背题_js.md"},i=t(`<h2 id="_1、图片异步上传" tabindex="-1">1、图片异步上传 <a class="header-anchor" href="#_1、图片异步上传" aria-label="Permalink to &quot;1、图片异步上传&quot;">​</a></h2><p>要实现图片上传，首先要拿到图片的数据，在前端页面，可以使用 input 标签设置属性 type = &quot;file&quot; 或者 其他组件的方法让用户选择需要上传的图片</p><p>为了减少上传时间和网络流量，可以在前端对图片数据进行压缩，可以使用 HTML5 的 Canvas API 或第三方库如 compressor js、image-compressor 等进行图片压缩</p><p>使用</p><h2 id="_2-常见的数据类型" tabindex="-1">2. 常见的数据类型 <a class="header-anchor" href="#_2-常见的数据类型" aria-label="Permalink to &quot;2. 常见的数据类型&quot;">​</a></h2><p>javaScript 的数据类型可以分为两种，一种是 值类型，也叫基本类型；还有一种是 引用类型</p><p>基本类型有：字符串string、数字number、布尔值boolean、null、undefined 以及 es6 新增的 symbol， 代表独一无二的值</p><p>而引用类型的数据有：对象Object、数组Array、函数Function、日期Date以及正则表达式RegExp等</p><h2 id="_3-常量的特点" tabindex="-1">3. 常量的特点 <a class="header-anchor" href="#_3-常量的特点" aria-label="Permalink to &quot;3. 常量的特点&quot;">​</a></h2><p>常量一般使用 const 来命名，常量的特点如下：</p><ol><li><p>常量的值一旦定义了就不能改变，但是如果是对象，可以修改对象中的值</p></li><li><p>必须在定义的时候就赋值，并且不能重新声明，也不能被删除</p></li><li><p>常量的作用域与变量相同，可以是全局或者局部的</p></li><li><p>常量可以是任何数据类型，包括字符串、数字、布尔值、对象等</p></li></ol><h2 id="_4、http协议" tabindex="-1">4、http协议 <a class="header-anchor" href="#_4、http协议" aria-label="Permalink to &quot;4、http协议&quot;">​</a></h2><p>HTTP 也叫做超文本传输协议，是一个属于应用层的面向对象的协议，在1990年提出，http协议的主要特点有：</p><ol><li><p>支持 客户端/服务器模式：客户端发送请求，服务器提供响应</p></li><li><p>简单快速：客户端向服务器发送请求时，只需填写 请求方法 和 请求的路径（url）就可以进行发送了， 常用的请求方法有 GET、POST、PUT、DELETE、HEAD等，通信速度很快</p></li><li><p>无状态：HTTP协议是无状态协议，每个请求都是独立的，（服务器不会记住之前的请求信息）</p></li><li><p>无连接：http协议也是一种无连接协议，处理完一个请求响应之后就会断开连接，这种方式可以节省传输时间</p></li><li><p>灵活：HTTP允许传输任意类型的数据对象，传输的类型可以用 Content-Type 来指定</p></li></ol><p>HTTP 请求由三部分组成：请求行、请求头、请求正文</p><ol><li><p>请求行：是以一个请求方法开头，以空格分开，后面跟着的是请求的 URL 和 http协议的版本（GET /index.html HTTP/1.1）</p></li><li><p>请求头：包含一系列键值对，如 Content-Type、User-Agent、Accept 等，它是可选的，可以根据需要来添加</p></li><li><p>请求正文：可以包含一些表单数据、JSON数据、也可以省略</p></li></ol><p>然后是 HTTP 响应，也通常是由 响应行、响应头、响应正文 组成</p><ol><li><p>响应行：包含 http 版本、状态码、状态描述，以空格分开（HTTP1.1 200 ok）</p><p>关于状态码:</p><pre><code> 以1开头表示请求接收到了、
 
 200 就表示请求成功了、
 
 3 零几开头的一般表示重定向了、 

 4 零开头的是客户端错误

 5 零开头的是服务器错误
</code></pre></li><li><p>响应头：也是包含一系列键值对，例如 Content-Type、Content-Length、Set-Cookie 等</p></li><li><p>响应正文：就是包含了我们需要的信息，例如 html 文件、JSON 数据、图片数据等等</p></li></ol><p><em><strong>追问</strong></em> http 和 https 的区别：</p><h2 id="_5-数组的常用方法" tabindex="-1">5. 数组的常用方法 <a class="header-anchor" href="#_5-数组的常用方法" aria-label="Permalink to &quot;5. 数组的常用方法&quot;">​</a></h2><p>push：向数组的末尾添加元素，返回数组的新长度</p><p>pop：把数组的最后一个元素弹出去，返回这个被删掉的元素</p><p>unshift：向数组的开头添加元素，返回数组的新长度</p><p>shift：把数组开头第一个元素删除，返回这个元素</p><p>slice(start, end)：返回原数组中指定位置的一个新的数组，(左闭右开，不包含end元素)</p><p>splice(index, num(0表示不删除，不指定就会往后一直删), ?item1, ?item2....)：</p><pre><code>表示可以添加或者删除元素，会改变原数组，第一个参数指定插入或删除的数组位置，第二个参数表示删除的个数
</code></pre><p>第三个以后的参数，是要插入到数组的新元素</p><p>sort： 这个方法可以对数组进行排序</p><p>然后es6新增了一些数组方法，比如：</p><p>forEach：遍历数组元素，执行参数的回调函数，返回 undefined</p><p>map：遍历数组，结束之后会返回一个新的数组</p><p>filter：用来筛选元素的，符合条件的元素会作为一个新的数组来返回</p><p>some：数组中只要有一个满足条件的，就返回 true，然后停止遍历</p><p>every：遍历数组所有的元素，只有都符合条件才返回true</p><p><em><strong>追问</strong></em>:</p><ol><li><p>slice,splice 的区别？</p></li><li><p>如何合并两个数组？</p></li><li><p>sort都有哪些参数？</p></li><li><p>数组去重有哪些方法？</p></li><li><p>如何把伪数组转换为数组？</p></li></ol><h2 id="_6、js-原生事件如何绑定" tabindex="-1">6、JS 原生事件如何绑定？ <a class="header-anchor" href="#_6、js-原生事件如何绑定" aria-label="Permalink to &quot;6、JS 原生事件如何绑定？&quot;">​</a></h2><ol><li><p>行内绑定，在标签上写上 on + 事件名称，例如点击事件 onClick，值为执行的函数</p></li><li><p>动态绑定，用 js 获取到 DOM元素对象，然后使用 DOM元素.事件名称</p></li><li><p>事件监听，同样先获取到 DOM元素对象，然后通过 .addEventListener(name, callBack) 传入事件名称和回调函数</p></li></ol><h2 id="_7、作用域和作用域链" tabindex="-1">7、作用域和作用域链 <a class="header-anchor" href="#_7、作用域和作用域链" aria-label="Permalink to &quot;7、作用域和作用域链&quot;">​</a></h2><p>作用域 就是程序中变量和函数的可访问的范围，在 JS 中，分为全局作用域和局部作用域</p><p>全局作用域：全局作用域的变量在程序中的任何地方都可以被访问到，window 对象的内置属性都拥有全局作用域</p><p>局部作用域：也叫函数作用域，在函数内部定义的变量，只能在函数内部中使用，当函数执行结束之后，这个函数作用域 会被销毁，其中的变量也会被回收</p><p>然后 ES6 中还新增了 块级作用域，比如用 let 声明的变量只能在块级作用域中使用，有“暂时性死区”的特性</p><p>作用域最大的用处就是隔离变量，不同作用域下的同名变量不会发生冲突</p><p>然后作用域链：</p><p>就是当程序访问一个变量的时候，首先是会在当前作用域中查找是否有定义了这个变量，如果没有找到的话，就会去 上一级的作用域中去查找，直到找到全局作用域为止，这个查找的过程像形成链条一样，这就是 作用域链</p><h2 id="_8、var、let、const的区别" tabindex="-1">8、var、let、const的区别 <a class="header-anchor" href="#_8、var、let、const的区别" aria-label="Permalink to &quot;8、var、let、const的区别&quot;">​</a></h2><p>var 是 JS 最早用来声明变量的方法，因此它会有一些历史遗留的问题，比如：</p><ol><li><p>变量提升，会提升到当前作用域的顶层，并且值为 undefined</p></li><li><p>可以重复声明变量，后面的声明会覆盖前面的</p></li><li><p>覆盖全局对象属性，变量提升的时候，如果在全局作用域中会提升到全局对象window上，也就是可能会覆盖一些 全局变量和方法</p></li></ol><p>然后在 ES6 新增了 let、const 两个关键字来声明变量，let 声明变量，const 声明常量，它们之间的不同点主要是：</p><ol><li><p>块级作用域，let 、const 有块级作用域，var 没有</p></li><li><p>暂时性死区，let 和 const 声明的变量不能在声明之前使用，不然会报错；而 var 可以在声明之前使用</p></li><li><p>初始值，const 定义的常量必须要有初始值，而 let 、var 可以不用设置初始值</p></li><li><p>重新赋值，let 、var 声明的变量可以重新赋值，而 const 不能，但是如果是对象的话，可以修改对象的属性值</p></li></ol><h2 id="_9、闭包" tabindex="-1">9、闭包 <a class="header-anchor" href="#_9、闭包" aria-label="Permalink to &quot;9、闭包&quot;">​</a></h2><p>闭包：就是能够读取其他函数内部变量的函数</p><p>闭包的作用是：</p><p>1、可以读取函数内部的变量</p><p>2、让变量的值始终保持在内存中</p><p>闭包需要注意的地方是：</p><p>1、闭包的变量都保存在内存中，会消耗很多内存，造成网页的性能问题，解决办法是，在退出函数之前， 将不使用的局部变量全部删除</p><p>2、父函数作为对象，内部函数作为方法，内部函数的变量作为私有属性，闭包会在父函数外部，改变 父函数内部变量的值</p><h2 id="_10、原型和原型链" tabindex="-1">10、原型和原型链 <a class="header-anchor" href="#_10、原型和原型链" aria-label="Permalink to &quot;10、原型和原型链&quot;">​</a></h2><p>在 JavaScript 中是通过构造函数来新建一个对象的，每一个构造函数都有一个内置属性叫 prototype 指向一个对象，</p><p>这个对象就是这个构造函数的原型，原型的作用呢，就是可以包含由某个构造函数 new 出来的所有实例对象都可以共享的属性和方法。</p><p>原型链就是：</p><p>当使用构造函数新建一个对象的时候，这个对象就会生成一个属性叫 <code>__proto__</code>指向了创建它的构造函数的 prototype 也就是原型</p><p>当我们访问对象的某一个属性的时候，如果这个对象没有这个属性，那它就会去它的原型对象里面去找这个属性，而原型对象也是有自己的原型对象的，</p><p>如果没有找到的话，就会继续往上找，直到找到 Object.prototype 指向的原型，也就是 null，null 是最顶级的了，在这个寻找的过程中，就像</p><p>形成了链条一样，这就是原型链的概念。</p><h2 id="_11、面向对象" tabindex="-1">11、面向对象 <a class="header-anchor" href="#_11、面向对象" aria-label="Permalink to &quot;11、面向对象&quot;">​</a></h2><p>在 es5 的时候是没有 class 类的概念的，但是可以通过构造函数和原型的方式去实现 class 类的这个类似功能</p><p>面向对象有三大特征：</p><ol><li><p>封装：把一种事物的属性和方法封装到对象中</p></li><li><p>继承：子对象可以继承父对象的属性和方法</p></li><li><p>多态：同一个方法，子对象可以继承也可以自定义来跟父对象的内容保持不同</p></li></ol><p>面向对象编程的优势：</p><p>容易维护、容易扩展、代码的质量和效率相对比较高</p><p>在 js 中，创建对象的方式有：</p><ol><li><p>通过字面量 {} 来创建</p></li><li><p>执行 Object 构造函数来创建</p></li><li><p>通过 new 构造函数的形式来创建</p></li></ol><p>然后遍历对象，可以通过：for ... in xx 方式来遍历</p><h2 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h2><p>设计模式就是一种被大家反复使用并且验证过的代码设计经验，是一种通用解决方案；它可以帮助 我们更好地去解决软件开发中常见的问题，提高代码的可维护性、写出来的代码更容易被人理解。</p><p>我们前端中常用到的设计模式主要有：</p><p>1、单例模式：一个类只能有一个实例，并提供一个访问它的全局访问点</p><ul><li>应用场景：浏览器的window对象（任何时候访问都是同一个对象）、弹窗（弹窗管理器，弹出顺序、次数）、全局状态管理store -- Vuex</li></ul><p>2、工厂模式：用固定的方式批量创建对象</p><ul><li>应用场景：vue3中的 createComponent（传入组件类型\\属性，返回不同组件实例）</li></ul><p>3、观察者模式：设置观察的方法，观察某个对象是否发生变化，是一种一对多的关系，当对象发生变化就会通知到所有的观测者，执行对应方法</p><ul><li>应用场景：事件绑定、promise 等</li></ul><p>4、发布/订阅者模式：发布者发布事件，通过中间层接收并通知订阅者，订阅者收到通知，更新对应的属性 执行对应的方法</p><ul><li>应用场景：典型的就是 vue中的 v-model 数据双向绑定</li></ul>`,88),o=[i];function r(n,s,c,h,d,_){return e(),l("div",null,o)}const b=p(a,[["render",r]]);export{m as __pageData,b as default};
