<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>博客 | 博客</title>
    <meta name="description" content="阿龙的学习笔记、个人博客网站">
    <link rel="preload stylesheet" href="/assets/style.9dca1cb4.css" as="style">
    <script type="module" src="/assets/app.9617a2f9.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.2ed14f66.woff2" as="font" type="font/woff2" crossorigin="">
  <link rel="modulepreload" href="/assets/chunks/framework.95b9d657.js">
  <link rel="modulepreload" href="/assets/chunks/theme.886c903b.js">
  <link rel="modulepreload" href="/assets/moment_src_必背题_vue.md.bad37d34.lean.js">
  <link rel="icon" href="/favicon.ico">
  <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-b2cf3e0b><!--[--><!--]--><!--[--><span tabindex="-1" data-v-b8b11faa></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-b8b11faa> Skip to content </a><!--]--><!----><header class="VPNav" data-v-b2cf3e0b data-v-7e5bc4a5><div class="VPNavBar" data-v-7e5bc4a5 data-v-7683ced7><div class="container" data-v-7683ced7><div class="title" data-v-7683ced7><div class="VPNavBarTitle" data-v-7683ced7 data-v-4d981103><a class="title" href="/" data-v-4d981103><!--[--><!--]--><!--[--><img class="VPImage logo" src="/favicon.ico" alt data-v-6db2186b><!--]--><!--[-->阿龙的网站<!--]--><!--[--><!--]--></a></div></div><div class="content" data-v-7683ced7><div class="curtain" data-v-7683ced7></div><div class="content-body" data-v-7683ced7><!--[--><!--]--><div class="VPNavBarSearch search" style="--vp-meta-key:&#39;Meta&#39;;" data-v-7683ced7><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-7683ced7 data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-7f418b0f data-v-5e623618 data-v-8f4dc553><!--[-->首页<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/guide/guide.html" tabindex="0" data-v-7f418b0f data-v-5e623618 data-v-8f4dc553><!--[-->指南<!--]--><!----></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-764effdf><span class="text" data-v-764effdf><!----> 面试题 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-764effdf><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link active" href="/moment_src/%E5%BF%85%E8%83%8C%E9%A2%98_vue.html" data-v-2f2cfafc data-v-8f4dc553><!--[-->vue相关<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-764effdf><span class="text" data-v-764effdf><!----> 前端基础 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-764effdf><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link" href="/vueNote/vue2/" data-v-2f2cfafc data-v-8f4dc553><!--[-->vue2<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link" href="/vueNote/vue3/" data-v-2f2cfafc data-v-8f4dc553><!--[-->vue3<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link" href="/others/uniapp.html" data-v-2f2cfafc data-v-8f4dc553><!--[-->uniapp<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link" href="/others/js.html" data-v-2f2cfafc data-v-8f4dc553><!--[-->javaScript<!--]--><!----></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link" href="/others/ts.html" data-v-2f2cfafc data-v-8f4dc553><!--[-->typeScript<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-764effdf><span class="text" data-v-764effdf><!----> 进阶知识 <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="text-icon" data-v-764effdf><path d="M12,16c-0.3,0-0.5-0.1-0.7-0.3l-6-6c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l5.3,5.3l5.3-5.3c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6C12.5,15.9,12.3,16,12,16z"></path></svg></span></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-2f2cfafc><a class="VPLink link" href="/guide/plus.html" data-v-2f2cfafc data-v-8f4dc553><!--[-->浏览器<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-7683ced7 data-v-f6a63727><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-f6a63727 data-v-82b282f1 data-v-f3c41672><span class="check" data-v-f3c41672><span class="icon" data-v-f3c41672><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-82b282f1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-82b282f1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-7683ced7 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink" href="https://github.com/hj-long" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-36371990><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-7683ced7 data-v-40855f84 data-v-764effdf><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-764effdf><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-764effdf><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-764effdf><div class="VPMenu" data-v-764effdf data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-40855f84><div class="item appearance" data-v-40855f84><p class="label" data-v-40855f84>Appearance</p><div class="appearance-action" data-v-40855f84><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-40855f84 data-v-82b282f1 data-v-f3c41672><span class="check" data-v-f3c41672><span class="icon" data-v-f3c41672><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-82b282f1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-82b282f1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-40855f84><div class="item social-links" data-v-40855f84><div class="VPSocialLinks social-links-list" data-v-40855f84 data-v-7bc22406><!--[--><a class="VPSocialLink" href="https://github.com/hj-long" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-36371990><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-7683ced7 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><!----></header><!----><!----><div class="VPContent" id="VPContent" data-v-b2cf3e0b data-v-a494bd1d><div class="VPDoc has-aside" data-v-a494bd1d data-v-c4b0d3cf><!--[--><!--]--><div class="container" data-v-c4b0d3cf><div class="aside" data-v-c4b0d3cf><div class="aside-curtain" data-v-c4b0d3cf></div><div class="aside-container" data-v-c4b0d3cf><div class="aside-content" data-v-c4b0d3cf><div class="VPDocAside" data-v-c4b0d3cf data-v-3f215769><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-3f215769 data-v-ff0f39c8><div class="content" data-v-ff0f39c8><div class="outline-marker" data-v-ff0f39c8></div><div class="outline-title" data-v-ff0f39c8>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-ff0f39c8><span class="visually-hidden" id="doc-outline-aria-label" data-v-ff0f39c8> Table of Contents for current page </span><ul class="root" data-v-ff0f39c8 data-v-9a431c33><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-c4b0d3cf><div class="content-container" data-v-c4b0d3cf><!--[--><!--]--><!----><main class="main" data-v-c4b0d3cf><div style="position:relative;" class="vp-doc _moment_src_%E5%BF%85%E8%83%8C%E9%A2%98_vue" data-v-c4b0d3cf><div><h2 id="_1、cookie-和-session-的区别" tabindex="-1">1、cookie 和 session 的区别 <a class="header-anchor" href="#_1、cookie-和-session-的区别" aria-label="Permalink to &quot;1、cookie 和 session 的区别&quot;">​</a></h2><p>cookie 和 session 都是用于客户端和服务器端之间进行状态管理的技术，它们的区别主要有：</p><ol><li><p>存储位置不同：</p><p>cookie 存储在客户端浏览器中，而session存储在服务器端的内存或者数据库中</p></li><li><p>安全性不同：</p><p>cookie 可以被客户端浏览器禁用或者删除，也容易被恶意攻击者窃取和篡改，因此存储敏感信息的安全性较低， 而session存储在服务器端，客户端无法直接访问，相对来说比较安全</p></li><li><p>存储容量不同：</p><p>cookie 的存储容量比较小，一般不超过4kb；而session的存储容量比较大，可以存储更多的信息</p></li><li><p>过期时间不同：</p><p>cookie的可以设置过期时间，可以长期保存在客户端浏览器中；而session的过期时间一般比较短，用户在关闭浏览器 或者一段时间不活动之后就会自动过期</p></li><li><p>用途不一样：</p><p>cookie主要用于客户端浏览器与服务器端之间的状态管理，比如保存用户登录信息、购物车信息等； 而session一般用于服务器端的状态管理，比如保存用户的会话信息、缓存数据等。</p></li></ol><p>总之，cookie和session都有各自的优缺点，具体使用哪种技术要看具体的需求和场景来决定。</p><h2 id="_2、slot-的使用" tabindex="-1">2、slot 的使用 <a class="header-anchor" href="#_2、slot-的使用" aria-label="Permalink to &quot;2、slot 的使用&quot;">​</a></h2><p>vue中的插槽有三种类型：匿名插槽、具名插槽、作用域插槽</p><ol><li><p>匿名插槽：</p><p>子组件通过 slot 标签来确定插槽渲染的位置，标签内可以放入Dom结构，当父组件在使用的时候没有往插槽传入内容， 标签内的dom结构就会显示在页面上；父组件在使用的时候，直接在子组件的标签内写入内容就可以了</p></li><li><p>具名插槽：</p><p>子组件通过 name 属性来表示插槽的名字，不传就为默认插槽；父组件在使用的时候在默认插槽的基础上加上 slot 属性， 值就是子组件的插槽的 name 属性值</p></li><li><p>作用域插槽：</p><p>子组件在作用域插槽上绑定属性将自身的信息传递给父组件来使用，这些属性会挂载到父组件的 v-slot 接收的对象上； 而 v-slot 可以简写为 #，父组件通过 # 加上插槽名字 来获取子组件的信息，在内容中使用。</p></li></ol><p>总结一下，有一些需要注意的地方：</p><ul><li><p>v-slot指令 只能在 template 标签上使用，但是当只有默认插槽的时候，可以在组件标签上使用</p></li><li><p>默认插槽的名字为 default ，可以省略 default 直接写 v-slot</p></li><li><p>当 v-slot 简写为 # 时，不能省略参数，写成 #default</p></li><li><p>可以通过解构获取子组件传递的变量：v-slot={user}，也可以重命名变量：v-slot=&quot;{user: aaa}&quot;，还可以设置默认值：v-slot=&quot;{user=&#39;默认1&#39;}&quot;</p></li></ul><h2 id="_3、computed-是怎么做响应式的" tabindex="-1">3、computed 是怎么做响应式的？ <a class="header-anchor" href="#_3、computed-是怎么做响应式的" aria-label="Permalink to &quot;3、computed 是怎么做响应式的？&quot;">​</a></h2><p>computed属性是vue中的计算属性，它是一个类似于过滤器的函数，主要用于对绑定到视图的数据进行处理</p><ul><li><p>computed 属性可以像data 属性一样定义，然后可以直接在模板中使用，但是它是一个函数并且必须要有一个返回值</p></li><li><p>computed 属性也是响应式的，它会自动追踪其他的响应式属性，例如 data中数据或者父组件传递的 props 中的数据 当它依赖的这些响应式属性发生变化时，computed属性会自动重新计算，然后通知组件，更新页面视图</p></li><li><p>计算属性的结果默认会走缓存，只有当它依赖的响应式属性发生变化才会重新计算，这可以提高性能，避免不必要的计算 （这跟method方法不同，method调用一次就重新计算一次，computed 调用多次如果值没变化就只会计算一次）</p></li></ul><h2 id="_4、vue2-和-vue3-的区别" tabindex="-1">4、vue2 和 vue3 的区别 <a class="header-anchor" href="#_4、vue2-和-vue3-的区别" aria-label="Permalink to &quot;4、vue2 和 vue3 的区别&quot;">​</a></h2><ol><li>数据双向绑定 的原理不同：</li></ol><p>在vue2中，数据双向绑定是利用 ES5 的一个 API 叫 Object.defineProperty 对数据劫持， 并且结合发布\订阅者模式的方式去实现的</p><p>而在vue3中，数据双向绑定是使用 es6 的 Proxy 方法对数据进行代理，</p><p>相比于 vue2 ，proxy 有几个好处：</p><ul><li><p>Object.defineProperty 只能监听对象的某个属性，不能对整个对象进行监听，因此 vue2 需要递归遍历所有的属性 去对数据进行劫持，而 proxy 可以直接对整个对象代理进行监听，因此节省了递归遍历等操作，明显提高了性能</p></li><li><p>可以监听数组，不用像vue2中那样对数组做特异性操作，vue3可以检测到数组内部数据的变化</p></li></ul><ol start="2"><li>vue3 支持 碎片化</li></ol><p>在vue2中，template 模板标签下必须并且只能有一个根节点</p><p>而在vue3中，可以支持多个根节点</p><ol start="3"><li>API 类型不同：</li></ol><p>在 vue2 中使用的是选项式API的写法，根据不同的属性来分割代码：data、computed、methods等， 当代码量比较大的时候，需要不断地上下翻滚查找数据和方法，会比较麻烦</p><p>而 vue3 采用的是 组合式API的写法，同一个业务的数据和方法写在同一个地方，相比于 vue2 的写法， vue3 的代码会更加方便和整洁</p><ol start="4"><li>定义数据变量和方法不同：</li></ol><p>vue2 的数据变量放到 data 中管理，创建的方法放到 methods 中管理，</p><p>而 vue3 的数据和方法是写到 setup 函数里面，setup 函数会在组件初始化构造的时候触发</p><ol start="5"><li>生命周期钩子函数不一样：</li></ol><p>vue2 中的生命周期有：</p><pre><code>组件创建前和后：beforeCreate、created

组件挂载前和后：beforeMount、mounted

数据更新前和后：beforeUpdate、Updated

以及组件销毁前后：beforeDestroy、destroyed
</code></pre><p>vue3 的生命周期把组件创建前后改成了 setup 函数</p><pre><code>组件挂载前和后：onBeforeMount、onMounted

数据更新前和后：onBeforeUpdate、onUpdated

组件销毁前后改了名称，叫：onBeforeUnMount、onMounted

并且 vue3 中的生命周期在使用之前要先引入。
</code></pre><ol start="6"><li>父子组件传参的方式不同</li></ol><p>vue2 中的 父传子，子组件使用 props 接收，而 子传父使用 this.$emit 传入事件名称 来触发父组件的方法并且通过参数传值</p><p>而在 vue3 的 setup 语法糖里面，父传子使用的是 defineProps 来接收，子传父使用的是 defineEmits</p><ol start="7"><li>插槽和指令不同</li></ol><ul><li><p>插槽：</p><p>vue2 中的插槽可以直接使用 slot 指令，而 vue3 中必须使用 v-slot 指令</p></li><li><p>指令：</p><p>vue2 中的 v-for 比 v-if 的优先级要高，并且不建议一起使用，而在 vue3 中，v-if 只是作为 v-for 的一个判断语句 不会相互冲突；</p><p>并且在 vue3 中，移除了 keyCode 作为 v-on 的修饰符，以及移除了 v-on.native 修饰符， 还有一个过滤器 filter 也从 vue3 中移除了</p></li></ul><ol start="8"><li>main.js 文件不同</li></ol><p>在 vue2 的main.js中，引入的是 Vue 的构造函数，并且可以使用 prototype 操作原型的方式去添加全局对象或者方法</p><p>在 vue3 中则是引入了一个名叫 createApp 的工厂函数，通过模块化的方式去组织代码，比 vue2 更加简洁</p><p>并且 vue3 的 app.vue 组件可以没有根标签</p><h2 id="_5、解释一下-mvvm" tabindex="-1">5、解释一下 MVVM <a class="header-anchor" href="#_5、解释一下-mvvm" aria-label="Permalink to &quot;5、解释一下 MVVM&quot;">​</a></h2><p>MVVM 就是 model-view-viewModel，本质上是 MVC 的改进版</p><p>model 代表数据模型，数据和业务逻辑都在model层定义</p><p>view 是用户在屏幕上看到的UI视图</p><p>viewModel 负责监听 model 中数据的改变并且控制视图的更新，以及处理用户的交互逻辑</p><p>MVVM 优点是：</p><ul><li><p>低耦合，view视图可以独立于model的变化和修改，一个viewModel可以绑定到不同的view上，view和model无直接的关联，互不影响</p></li><li><p>可复用性强，就是开发者可以把一些视图逻辑放在一个viewModel里面，让很多view可以复用这段逻辑</p></li><li><p>独立开发，业务逻辑和视图表现是分离，开发者可以专注于业务逻辑，不用过多关注界面的细节</p></li></ul><h2 id="_6、vue-的特点" tabindex="-1">6、vue 的特点 <a class="header-anchor" href="#_6、vue-的特点" aria-label="Permalink to &quot;6、vue 的特点&quot;">​</a></h2><p>vue 是一个轻量级的 JavaScript 框架，专注于视图层开发，用于构建单页面应用</p><p>vue 使用 MVVM 架构，将视图层、数据层和业务逻辑分离开来，通过一些简单的API实现响应式的数据绑定和可以组合的视图组件， 让开发者可以更方便地开发和维护复杂的前端应用</p><p>vue 的特点：</p><ol><li><p>数据双向绑定机制：就是说当数据发生变化时，视图也会进行更新，不需要手动去操作 DOM</p></li><li><p>组件化开发：把代码分割成一个个独立的组件，方便我们开发和复用，同时也可以提高代码的可维护性和可扩展性</p></li></ol><p>此外，vue 还有丰富的插件生态，比如路由管理的 vueRouter、状态管理的 vuex 等，提高开发效率</p><p>总的来说，vue 的优点在于它的灵活性和轻量级，它的语法、指令简单明了，学习成本低， 不管是小型应用还是大型单页面应用，都可以使用 vue 来实现</p><h2 id="_7、什么是单页面应用-spa" tabindex="-1">7、什么是单页面应用（SPA） <a class="header-anchor" href="#_7、什么是单页面应用-spa" aria-label="Permalink to &quot;7、什么是单页面应用（SPA）&quot;">​</a></h2><p>单页面应用，也叫 single-page application 简称 SPA，也就是加载单个页面并在交互时动态刷新该页面，所有的 活动都在一个页面中进行。</p><p>单页面应用在初始化时加载相应的HTML、CSS、JavaScript 文件，利用 js 动态的切换 HTML，从而实现UI与用户的交互效果</p><p>vue 框架为单页面应用开发提供了模板、路由和DOM操作以及异步访问数据api等功能，使得前后端分离开发成为了可能</p><p>SPA的优点是：</p><ol><li><p>前后端分离开发，减轻了服务器的压力；</p></li><li><p>移动端和PC端等可以共用一套后端接口程序代码，节省了开发成本。</p></li></ol><p>SPA的缺点是：</p><ol><li><p>SEO 难度比较高，首次加载时耗时比较长</p></li><li><p>页面前进、后退的管理比较困难</p></li></ol><p>针对单页面应用的前进后退的管理问题，我们可以引入 vueRouter 实现单页面应用的路由配置和导航控制， 通过浏览过的一个历史记录，查看过往的页面</p><p>还有首次加载耗时长的问题，可以采用多种缓存措施，在需要的时候再进行加载模块，比如路由懒加载、数据懒加载等</p><p>最后是 SEO 优化问题，由于单页面应用的数据是动态刷新的，导致网页内容很难被搜索引擎抓取到。</p><p>一般有两种解决方案：一种是服务端渲染，还有一种是前端预渲染。</p><p>关于前端预渲染：</p><ol><li><p>使用插件 prorender-spa-plugin，下载安装之后在 vue.config.js 中进行配置， 配置好这个默认预编译的路径、路由和渲染方式</p></li><li><p>然后在 main.js 中引入，并且要把 vueRouter 路由模式改成 history,然后进行打包</p></li></ol><h2 id="_8、data为啥是函数" tabindex="-1">8、data为啥是函数 <a class="header-anchor" href="#_8、data为啥是函数" aria-label="Permalink to &quot;8、data为啥是函数&quot;">​</a></h2><p>在 Vue 组件中，<code>data</code> 必须是一个函数，是因为组件可能会被多次实例化。对象是引用数据类型, 如果 <code>data</code> 是一个对象， 那么所有组件实例会共享同一个数据对象，引用的是同一个内存地址。这样一来，当一个组件实例修改了数据， 所有其他实例的数据也会被更改，这是我们不希望看到的</p><p>而如果 data 是一个函数，它会创建一个函数作用域作为自己的私有域，这样就使得每个组件实例中的 data 都是独立的数据，互不影响， 可以保证组件的一个正常工作。</p><h2 id="_9、数据双向绑定的原理" tabindex="-1">9、数据双向绑定的原理 <a class="header-anchor" href="#_9、数据双向绑定的原理" aria-label="Permalink to &quot;9、数据双向绑定的原理&quot;">​</a></h2><p>vue 中实现的这个数据双向绑定，首先要对数据进行劫持监听，用到了 Object.definedProperty() 的 get 和 set 方法， 然后还需要一个监听器 Observer，来监听所有属性。如果属性发生了变化，就告诉订阅者 Watcher 看是否需要更新。</p><p>因为 订阅者 是有很多个的，所以需要有一个消息订阅器 Dep 来专门收集这些订阅者， 然后在监听器 Observer 和 订阅者 Watcher 之间进行一个统一管理。</p><p>接着，我们还需要有一个指令解析器 Compile，对每个元素节点进行扫描和解析， 将相关指令对应初始化成一个订阅者 Watcher，并且替换模板数据或者绑定相应的函数，</p><p>此时当订阅者 Watcher 接收到相应属性的变化时，就会触发执行对应的更新函数， 这一点是在 js 文档碎片中完成的，从而更新了视图。</p><p>以上就是我所了解的数据双向绑定的原理~</p><h2 id="_10、computed、methods、watch" tabindex="-1">10、computed、methods、watch <a class="header-anchor" href="#_10、computed、methods、watch" aria-label="Permalink to &quot;10、computed、methods、watch&quot;">​</a></h2><p>computed 是 vue 中的计算属性，它可以用来解决模板过重的问题。计算属性必须要 return 返回一个结果， 并且具有缓存功能，可以提高性能。</p><p>computed 注重这个计算结果，不支持异步操作。</p><p>methods 选项是用来存放方法的，方法可以用来处理事件绑定和逻辑计算，跟 computed 不同， 方法可以不用 return 一个结果，并且没有缓存功能。</p><p>watch 可以用来监听某一个值的变化，在值发生变化的时候可以做一些操作。watch 也可以不用 return 返回值， 也没有缓存。但是它同时支持异步或者同步操作。</p><p>总之，computed、methods以及 watch 都是用于处理数据的选项，可以根据具体的业务需求和场景来使用。</p><h2 id="_11、v-if-和-v-show-的区别" tabindex="-1">11、v-if 和 v-show 的区别 <a class="header-anchor" href="#_11、v-if-和-v-show-的区别" aria-label="Permalink to &quot;11、v-if 和 v-show 的区别&quot;">​</a></h2><p>v-if 和 v-show 这两个指令都可以用来控制 DOM 元素的显示和隐藏，不同的是：</p><p>v-if 是真正的条件渲染，它会在元素显示隐藏的切换过程中销毁和重建条件块内的事件监听器和子组件； 而v-show只是简单的基于CSS样式来进行切换。</p><p>v-if 在首次渲染时，如果条件为真，就会创建和渲染条件块的元素，如果条件为false，那它什么也不会做；</p><p>而 v-show 在首次渲染时，不管条件为真还是假，都会创建和渲染元素</p><p>总结一下，v-if 是切换的开销高，v-show 的初次渲染的开销才比较高，</p><p>因此，如果是需要频繁进行切换的场景，使用 v-show 性能会更好，如果条件很少改变，使用v-if可能会比较好。</p><p>但还是需要结合具体的业务需求和场景来选择使用。</p><h2 id="_12、为什么-v-for-中必须要有-key" tabindex="-1">12、为什么 v-for 中必须要有 key <a class="header-anchor" href="#_12、为什么-v-for-中必须要有-key" aria-label="Permalink to &quot;12、为什么 v-for 中必须要有 key&quot;">​</a></h2><p>key 是 虚拟DOM 中用于识别节点的唯一标识符，它可以帮助 vue 高效地更新虚拟DOM，避免元素错乱等问题。 例如，在使用 v-for 渲染列表时，如果没有给每个元素加上一个唯一的key，就会导致元素发生错乱。</p><p>vue 的DOM操作默认采用“就地复用”策略，也就是说，当数据项的顺序发生变化时， vue会复用已有的元素来提高性能，而不是重新创建DOM元素。</p><p>最后需要注意的是，key 属性的类型只能是 number 或者 string 类型。</p><p>以上就是我了解的为什么要有 key 的原因</p><p><em><strong>追问</strong></em>：key 的作用原理</p><h2 id="_13、vue-中的指令" tabindex="-1">13、vue 中的指令 <a class="header-anchor" href="#_13、vue-中的指令" aria-label="Permalink to &quot;13、vue 中的指令&quot;">​</a></h2><p>指令就是针对 DOM 和数据操作而定义的一组具有特殊功能的命令</p><p>指令分为 系统指令 和 自定义指令</p><ol><li><p>系统指令主要有：v-if、v-show、v-for、v-model、v-text、v-html 等</p></li><li><p>自定义指令可以分为：全局自定义指令 和 局部自定义指令</p></li></ol><ul><li><p>全局自定义指令：</p><p>在全局文件main.js中通过 directive 属性挂载 Vue 构造函数上</p></li><li><p>局部自定义指令：</p><p>在组件的钩子函数 directives 中进行声明</p></li></ul><ol start="3"><li><p>应用场景：</p><p>用于数据类的，格式化一些内容、校验等，例如：微博的评论，有个显示评论时间的， 我们可以通过自定义指令，把时间小于2分钟的改成 刚刚、时间超过两分钟就显示 2分钟前、3分钟前...</p><p>还有可以用于控制元素的状态比如是否可用、如按钮的权限控制等等</p></li></ol><p><em><strong>追问</strong></em>：vue 中自定义指令怎么实现的？</p><ol><li>全局自定义指令：</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// vue2 写法，在 Vue 构造函数中挂载</span></span>
<span class="line"><span style="color:#A6ACCD;">Vue.directive()</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// vue3 写法，在实例对象 app 上挂载</span></span>
<span class="line"><span style="color:#A6ACCD;">app.directive(&#39;指令名称&#39;, (el, binding) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    // el 是绑定的元素, binding 是绑定指令的对象，binding.value 可以获取绑定属性值</span></span>
<span class="line"><span style="color:#A6ACCD;">    //可选生命周期：created、beforeMount、Mounted、beforeUpdate、updated、beforeUnMount、UnMounted</span></span>
<span class="line"><span style="color:#A6ACCD;">})</span></span></code></pre></div><ol start="2"><li>局部自定义指令：在组件中注册使用，在组件的钩子函数 directives 中进行声明</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">// 选项式写法：</span></span>
<span class="line"><span style="color:#A6ACCD;">directives: {</span></span>
<span class="line"><span style="color:#A6ACCD;">    &#39;xxx&#39;: {</span></span>
<span class="line"><span style="color:#A6ACCD;">        mounted(el, binding) {xxx}</span></span>
<span class="line"><span style="color:#A6ACCD;">        .....</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">// setup 语法糖</span></span>
<span class="line"><span style="color:#A6ACCD;">const vColor = {</span></span>
<span class="line"><span style="color:#A6ACCD;">    mounted(el, binding) {xxx}</span></span>
<span class="line"><span style="color:#A6ACCD;">    .....</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><h2 id="_14、vue的生命周期、-mounted-和-created-的区别" tabindex="-1">14、vue的生命周期、 mounted 和 created 的区别 <a class="header-anchor" href="#_14、vue的生命周期、-mounted-和-created-的区别" aria-label="Permalink to &quot;14、vue的生命周期、 mounted 和 created 的区别&quot;">​</a></h2><p>vue2 完整的生命周期，主要包括以下四个阶段：创建、挂载、数据更新、组件销毁</p><ul><li><p>组件创建前的生命周期是：beforeCreate 创建后：created</p></li><li><p>挂载到DOM前的生命周期是：beforeMount 挂载后：mounted</p></li><li><p>组件数据更新前：beforeUpdate 更新后：updated</p></li><li><p>组件销毁之前： beforeDestroy 销毁后：destroyed</p></li></ul><p>还有当组件初次加载时，会执行前面4个生命周期，就是：beforeCreate、created、beforeMount、mounted</p><p>如果使用了 keep-alive 就会新增两个生命周期，分别是：activated 和 deactivated。</p><p>关于生命周期钩子函数，它们在组件的不同阶段运行，完成一些特定的操作：</p><ol><li><p>beforeCreate：这个生命周期是组件创建之前调用，此时数据观测和事件初始化还没开始，data的响应式追踪、 event\watcher 都还没被设置，也就是说这时候不能访问到data、methods、computed、watcher 上面的方法和数据</p></li><li><p>created： 这时候组件实例创建好了，并且实例上面配置了：data、methods、computed、watcher等选项里面的 数据和方法，但是此时渲染节点还没开始挂载到DOM上，因此访问不到 <code>$el</code> 属性</p></li><li><p>beforeMount：是在组件实例挂载之前调用，此时实例完成了模板编译，并将 data 里面的数据生成虚拟DOM</p></li><li><p>mounted：这时是在 el 被新创建的 vm.$el 替换，并且挂载到实例上之后调用。</p></li><li><p>beforeUpdate：数据更新时调用，发生在虚拟DOM重新渲染之前</p></li><li><p>updated：由于数据更改导致虚拟 DOM 重新渲染，然后就会调用这个生命周期，此时 页面上的 DOM 已经更新了</p></li><li><p>beforeDestroy：实例销毁之前调用。在这一步，组件实例还是完全可用的</p></li><li><p>destroyed：组件实例销毁之后调用。调用后，vue实例会解除所有的数据绑定，包括所有的事件监听器， 子组件实例等都会被销毁解除</p></li></ol><p>还有一个特殊的 errorCaptured：会在捕获到一个来自子孙组件的错误时被调用</p><h3 id="vue3-的生命周期跟-vue2-的大同小异-但是用法和名字不太一样了" tabindex="-1">vue3 的生命周期跟 vue2 的大同小异，但是用法和名字不太一样了 <a class="header-anchor" href="#vue3-的生命周期跟-vue2-的大同小异-但是用法和名字不太一样了" aria-label="Permalink to &quot;vue3 的生命周期跟 vue2 的大同小异，但是用法和名字不太一样了&quot;">​</a></h3><p>vue3 中 组件创建前后beforeCreate和created 改为使用 setup 函数， 组件的数据和方法在 setup 函数中定义。</p><p>然后 组件挂载到页面渲染前后的生命周期、还有数据更新前后的生命周期，在 vue2 的基础上，多加了 on 在名字前面，</p><p>例如：onBeforeMount、onMounted、onBeforeUpdate、onUpdated</p><p>最后组件销毁前后的生命周期的名字改为了 unMounted：</p><p>销毁前：onBeforeUnMount、销毁后：onUnMounted</p><h3 id="create-和-mounted-的区别" tabindex="-1">create 和 mounted 的区别： <a class="header-anchor" href="#create-和-mounted-的区别" aria-label="Permalink to &quot;create 和 mounted 的区别：&quot;">​</a></h3><p>created 是在组件渲染之前调用的，能拿到数据但是拿不到模板的</p><p>mounted 是在组件数据挂载并且渲染页面之后调用的，因此模板和数据都可以拿到</p><h2 id="_15、组件通信" tabindex="-1">15、组件通信 <a class="header-anchor" href="#_15、组件通信" aria-label="Permalink to &quot;15、组件通信&quot;">​</a></h2><ol><li><p>父传子：</p><p>父组件通过在子组件标签上用 v-bind:属性名=&#39;data&#39;，绑定属性名，值为父组件中的data数据变量， 而子组件使用 props:[&#39;data&#39;]，用数组或者对象的形式声明属性值来接收父组件传递过来的数据</p></li><li><p>子传父：</p><p>子组件通过 this.$emit() 向父组件发送事件，在父组件中定义这个事件和对应回调方法，数据会以参数形式 传递到父组件中</p></li><li><p>兄弟组件通信：</p><p>通过新建一个 bus.js 文件，里面 new 一个 vue 组件实例并且导出这个实例，然后假设有 A 、B 两个兄弟组件 在 A 组件中导入这个 bus.js，使用 bus.$emit() 传递事件和参数数据，然后 B 组件中也引入 bus.js ， 使用 bus.$on() 来接收事件和定义回调函数来处理传递过来的参数</p></li></ol><p>还可以使用 vuex 或者 pinia 的方式来通信：<a href="#16vuex-的理解">vuex的理解</a></p><h2 id="_16、vuex-的理解" tabindex="-1">16、vuex 的理解 <a class="header-anchor" href="#_16、vuex-的理解" aria-label="Permalink to &quot;16、vuex 的理解&quot;">​</a></h2><p>vuex 是 vue.js应用程序 的状态管理库，就像一个 store 仓库，保存着程序中的大部分状态，它的核心概念有：</p><p>state： 是数据源，用来保存所有组件的公共数据</p><p>getter：getters 的返回值会被缓存下来，只有当它的依赖值发生变化才会重新计算，类似于计算属性</p><p>mutations：定义方法用来更新 state 中的数据，必须是同步的，在组件中通过 store.commit 来调用</p><p>actions：actions 可以使用异步方法，在组件中通过 store.dispatch 来调用并提交到 mutations 来更改数据</p><p>最后一个是 module：当应用程序比价大的时候，通过 module 可以包含其他的 vuex 模块</p><p>但是 vuex 存储的数据在刷新页面就会丢失，因此需要做持久化存储：</p><ol><li><p>可以使用 localStorage 做持久化存储，</p></li><li><p>也可以使用第三方插件：比如 vuex-persistedstate ，安装之后在 store/index.js 中 引入插件，然后在 new vuex.store 中配置一下这个 plugins: [createPersistedState()]，这样 vuex 的数据就会持久化到 localStorage 中</p></li></ol><p>这个插件本质上也是利用 localStorage 进行持久化存储的</p><p><em><strong>追问</strong></em>：在什么场景下应用 vuex</p><p>如果项目中有需要在多个组件之间管理和共享状态的数据，就可以使用 vuex 来解决，例如 我之前做的一个项目里有一些商品需要收藏 或者类似小说网站那种书签、小说收藏、书架数据、搜索框历史记录等功能，就可以使用 vuex 来管理。</p><p>例如收藏夹功能就可以在 vuex 中 state 记录商品数据信息列表，当本地有就直接用本地的数据，如果没有，就从接口请求回来。</p><p>（如果数据比较重要，就发送到后端进行保存，如果数据不重要，就本地存储就好了）</p><h2 id="_17、get-和-post-的区别" tabindex="-1">17、get 和 post 的区别 <a class="header-anchor" href="#_17、get-和-post-的区别" aria-label="Permalink to &quot;17、get 和 post 的区别&quot;">​</a></h2><p>get 和 post 是 http 协议中两种不同的请求方法</p><p>get 请求一般用来查询数据，通过 url 传递参数，就是拼接到 url 后面，而且参数有长度限制，只能用 url 来编码， 还有一点是 get 请求可以被缓存下来，也可以添加到浏览器书签上。</p><p>post 请求一般用来提交数据的，例如提交表单数据或者文件文件上传等，post 请求的参数放到请求体中，参数的长度没有限制 也可以使用多种编码方式，跟get请求不同，post不能被缓存。</p><h2 id="_18、常见的跨域方式" tabindex="-1">18、常见的跨域方式 <a class="header-anchor" href="#_18、常见的跨域方式" aria-label="Permalink to &quot;18、常见的跨域方式&quot;">​</a></h2><p>跨域是由于浏览器的同源策略导致的，在浏览器中，如果当前页面请求一个不同源的url时，就会触发这个跨域的问题，常见的解决方法有：</p><ol><li><p><strong>jsonp</strong>：利用script标签不受同源策略影响的特性，动态创建 script 标签，src 属性值就为请求的url，来获取其他域下的数据； 同时将回调函数作为参数传递给服务器，服务器在响应时将数据作为回调函数的参数来返回，响应完成时，客户端通过执行回调函数来获取数据。</p></li><li><p><strong>CORS</strong>：跨域资源共享，它允许服务器端通过设置响应头比如 <code>Access-Control-Allow-Origin</code> 来告诉浏览器允许这个跨域请求， 前端在发送请求时在请求头加上 Origin 字段就可以了。这个也是官方推荐的一种跨域解决方案。</p></li><li><p><strong>使用代理服务器跨域</strong>：通过代理服务器将跨域请求转发到目标服务器，有好几种实现方法，可以使用 Nginx 进行反向代理， 也可以在 vue 项目中的一个配置文件中设置 proxy 属性来开启代理服务</p></li><li><p><strong>postMessage</strong>：html5 的 window.postMessage 方法，第一个参数为发送的消息，第二个参数为指定域地址， 然后通过 window.addEventListener(&#39;message&#39;,()=&gt;{}) 监听 window 的 message 事件来接收传递的信息</p></li><li><p><strong>使用 WebSockets</strong>： WebSockets 可以实现跨域通信，因为它们不受同源策略限制。通过建立一个 WebSocket 连接， 客户端和服务器可以进行双向通信，实现跨域数据交换。(new 一个 WebSockets 实例，然后监听实例的 open 事件，在回调里 发送数据 <code>.send()</code>, 监听实例的 message 事件，可以接收到服务器发来的信息，还有 close 事件)</p></li></ol><h2 id="_19、axios-二次封装" tabindex="-1">19、axios 二次封装 <a class="header-anchor" href="#_19、axios-二次封装" aria-label="Permalink to &quot;19、axios 二次封装&quot;">​</a></h2><p>axios 是一个基于 promise 的网络异步请求库，我们可以对它进行二次封装方便我们使用：</p><p>新建 utils/request.js ，导入 axios，可以设置 baseURL、timeOut超时时间等一些基础配置项，</p><p>然后可以给请求、响应各封装一层拦截器：</p><ol><li><p>请求拦截器 interceptors.request.use，可以在这里设置每个请求携带是否 token 等操作</p></li><li><p>响应拦截器 interceptors.response.use，收到响应之后的处理，可以在这里处理不同状态码的操作</p></li></ol><p>然后我们可以根据需要，去封装 get请求、post请求等不同请求方法，进一步简化请求的调用方式，这样在 使用的时候，直接填入 url 和 参数就可以了。</p><p>但是如果想要更好维护的话，还可以再封装一层 api 的解耦，根据不同的模块定义每一个请求的接口函数， 这样可以根据需要去调用，也可以使用 ts 类型接口去约束请求需要的参数类型，方便我们使用</p><p>例如 获取个人信息的接口、查询字典的接口 可以封装成一个个api函数，例如我之前的项目中 有这个用户管理页它需要查询字典这个接口去查询该页面的用户是否有这个 启用 的功能，然后还有角色管理同样 也需要这个 查询字典的 接口查询角色是否可以启用，因此这两个页面就可以直接引入api接口函数来使用就可以了 比较方便嘛</p><h2 id="_20、async-和-await" tabindex="-1">20、async 和 await <a class="header-anchor" href="#_20、async-和-await" aria-label="Permalink to &quot;20、async 和 await&quot;">​</a></h2><p>async 用来定义异步函数，该函数不会阻塞后面的代码。async 语句会把这个函数包装成promise对象，可以使用 .then 获取返回值</p><p>async 函数内部原理是：</p><p>如果这个 async 函数有返回值，就会使用 resolve() 把它转化成promise对象来返回</p><p>如果这个 async 函数内部报错了，调用 reject() 返回 promise 对象，可以用 catch 来捕获错误</p><p>然后 await 语句，是等待的意思，它必须要在 async 函数内部配合使用，await后面一般跟着promise对象， 它会把async函数挂起，直到promise对象返回结果才继续往下执行</p><p>async 和 await 的优势是：</p><p>它可以像写同步代码一样来写异步代码，比 promise 写法更直观一点，提高效率（promise 解决了回调地狱问题）</p><h2 id="_21、接口安全" tabindex="-1">21、接口安全 <a class="header-anchor" href="#_21、接口安全" aria-label="Permalink to &quot;21、接口安全&quot;">​</a></h2><p>前后端在进行数据传输的时候，为了防止请求被抓包、伪造、偷窥等情况，一般需要对数据进行加密， 我们前端常用的有 md5，crypto、jsencrypt 等…</p><p>说一下我们之前常用的加密解密方式：</p><p>第一种是 crypto，属于 AES 算法，首先通过 npm 下载，然后在 utils/cryptoAES.js 文件， 导入 crypto，定义一个加密函数和一个解密函数</p><p>其中就会用到密钥和偏移量，这个密钥跟偏移量是前后端约定好的。使用的时候在组件组件中导入这个文件就可以了， 然后使用加密函数对数据进行加密，发送到后端。后端返回的数据如果是加密的，就可以使用解密函数来解密得到正确的信息</p><p>第二种是 jsencrypt，它是属于 RSA 加密，RSA 是一种非对称加密算法，可以双向加密解密，用到一对公钥和私钥， 使用 公钥加密的数据需要用对应的私钥来解密，使用私钥加密就需要使用对应的公钥来解密，前后端各自保存着对应的公钥私钥， 也就是说，就算有人在前端的拿到了公钥或者私钥也没办法去解密，因为对应的私钥或公钥在后端，因此加密安全级别很高。</p><p>使用方法也很简单，通过 npm 下载，导入并且定义一个加密函数一个解密函数，然后再使用就可以了</p><h2 id="_22、-对单向数据流的理解" tabindex="-1">22、 对单向数据流的理解 <a class="header-anchor" href="#_22、-对单向数据流的理解" aria-label="Permalink to &quot;22、 对单向数据流的理解&quot;">​</a></h2><p>在vue中，单向数据流的一个体现是在 父子组件通信上：</p><p>父组件通过 props 向子组件传递的数据，子组件不能直接修改，修改就会报错，而如果父组件的数据更新了， 子组件的也会跟着变化，这就是单向数据流，这种方式可以确保数据只能从父组件流向子组件，这样可以很好追踪数据源的变化， 降低程序出错可能性。</p><p>如果子组件想要修改父组件的传递的数据：</p><ol><li><p>可以在子组件 data 中新建一个变量赋值 props 中的值，然后再去修改这个变量就可以了</p></li><li><p>可以通过 this.$emit 发出一个事件，父组件收到事件去做相应的一个修改逻辑</p></li></ol><h2 id="_23、对路由的理解" tabindex="-1">23、对路由的理解 <a class="header-anchor" href="#_23、对路由的理解" aria-label="Permalink to &quot;23、对路由的理解&quot;">​</a></h2><p>在 vue 中，路由是可以根据不同的 url 来切换显示不同内容的控制器、通常使用 vue-router 来实现路由功能</p><p>路由有两种模式：hash 和 history，默认使用hash模式，在 router/index.js 中配置</p><p>hash 路由模式会在 url 后面带有一个 # 号，当 url 的hash发生变化时，浏览器不会重新加载整个页面，而是会触发 hashchange事件，就可以通过js来监听这个事件实现数据的加载和页面渲染；</p><p>而 history 模式会刷新页面，会向后台服务器发送请求，如果后台没有定义这个路径的话，会返回404，因此需要后台配置重定向</p><p>路由的使用方法：首先需要通过 npm 下载 vue-router，需要在 src/router/index.js 中引入 vue-router， 需要配置路由表，包括 path、name、component、children 等属性</p><p>然后还可以分为静态路由和动态路由：</p><ol><li><p>静态路由：就是路由的path固定不变的</p></li><li><p>动态路由：路由的path/：参数名称，比如说：<code>path:&quot;/users/:id&quot;</code>，：号跟着一个参数id，在组件中使用的时候，通过 this.$router.push(url, 参数) 进行带参数跳转，可以使用 query 和 params 来传参</p></li></ol><p>然后还有 $route 和 $router 的一个区别：</p><ol><li><p>$route：表示当前的路由信息，包含了当前页面的url路径、参数、query对象等内容</p></li><li><p>$router 对象是全局的路由实例，包含一系列路由方法：</p><ul><li><p>比如 router-link 标签，可以声明一个路由链接</p></li><li><p>this.$router.push() 可以向 history 栈中添加一个新的记录</p></li><li><p>this.$router. replace() 替换，这个不会向 history 栈中添加新记录</p></li><li><p>this.$router.go(n) 方法，可以传递数字参数n，可以是正整数也可以负整数，表示向前或者向后跳转 n 个页面</p></li></ul></li></ol><p>还有路由的懒加载，可以按需加载路由文件，减少首页加载时间，避免首页出现白屏</p><p>最后是路由守卫：</p><ol><li><p>全局路由守卫：放在 main.js 的 router 实例上，定义 beforeEach((to:即将进入, from:当前离开, next:下一步) =&gt; {})，afterEach((to, from)=&gt;{})</p></li><li><p>局部路由守卫：在每个组件中定义的，beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</p></li><li><p>路由独享守卫：只在当前的路由中生效，有两个守卫方法 前置守卫beforeEach、后置守卫afterEach， 在 /router/index.js 中配置的一个个路由信息下定义，只在当前路由生效</p></li></ol><p><em><strong>追问</strong></em>：hash模式 和 history模式 的原理和区别</p><p>hash 路由模式：会在 url 后面带有一个 # 号，当 url 的hash发生变化时， 浏览器不会重新加载整个页面，而是会触发hashchange事件，就可以通过js来监听这个事件 实现数据的加载和页面渲染</p><p>而 history 模式：会刷新页面，会向后台服务器发送请求，如果后台没有定义这个路径的话， 会返回404，因此需要后台配置重定向</p><p>hash 模式的优缺点是：</p><pre><code>兼容性好，所有浏览器都支持运行使用，缺点是 url 中带有 # 号，可能不太美观
</code></pre><p>history 模式的优缺点是：</p><pre><code>url美观嘛，用户体验好，但是兼容性不太好，需要跟后端来配合使用
</code></pre><h2 id="_24、vue中如何动态添加属性-首先应该想到-动态-class-style-切换" tabindex="-1">24、vue中如何动态添加属性（首先应该想到： 动态 class\style 切换，） <a class="header-anchor" href="#_24、vue中如何动态添加属性-首先应该想到-动态-class-style-切换" aria-label="Permalink to &quot;24、vue中如何动态添加属性（首先应该想到： 动态 class\style 切换，）&quot;">​</a></h2><p>在 vue 中，可以使用 v-bind 指令实现动态绑定属性，v-bind 指令可以将data中的变量绑定到指定的 html 属性上，缩写为： &#39;:&#39;</p><p>可以定义 class类名、style样式，通过 v-bind 绑定class和style属性，改变变量值，可以进行动态切换的效果</p><h2 id="_25、vue-中如何做样式穿透" tabindex="-1">25、vue 中如何做样式穿透 <a class="header-anchor" href="#_25、vue-中如何做样式穿透" aria-label="Permalink to &quot;25、vue 中如何做样式穿透&quot;">​</a></h2><p>在vue中，可以在想要穿透的样式选择器前面加上 &gt;&gt;&gt; 符号 或者 /deep/ 或者 ::v-deep 就可以了</p><h2 id="_26、keep-alive-组件缓存-保持状态怎么实现刷新" tabindex="-1">26、keep-alive 组件缓存，保持状态怎么实现刷新 <a class="header-anchor" href="#_26、keep-alive-组件缓存-保持状态怎么实现刷新" aria-label="Permalink to &quot;26、keep-alive 组件缓存，保持状态怎么实现刷新&quot;">​</a></h2><p>keep-alive 是 vue 中内置组件，可以保存组件的状态，避免组件重复渲染</p><p>它的使用方法很简单，只需要用 keep-alive 标签包裹着要缓存的组件就可以了，这样在切换组件时，组件就不会被销毁而是保存起来</p><p>可以使用 include 属性去选择哪些组件需要进行缓存，可以动态绑定一个数组，数组里面放的就是需要缓存的组件的name属性值</p><p>有两个独有的生命周期：activated：激活 和 deactivated：停用，可以写业务逻辑，如果要保存上一个页面的状态，则需要 使用局部路由守卫，在 beforeRouteLeave 函数中把当前页面路径以变量形式存放，在 activated 生命周期中，把跳转到变 量所保存的路径，既可以实现状态保存了</p><p>使用 keep-alive 组件在第一次加载时，会触发正常组件的生命周期基础上再多一个 activated。 如 beforeCreate、created、beforeMount、mounted</p><p>如果第二次或者之后，就只会触发 activated 这个生命周期</p><p>总之，使用 keep-alive 的优势是：在组件切换过程中并不会销毁而是缓存到内存中， 可以防止重复渲染DOM，减少加载时间，提高性能以及用户的体验</p><h2 id="_27、token-保存在哪里" tabindex="-1">27、token 保存在哪里？ <a class="header-anchor" href="#_27、token-保存在哪里" aria-label="Permalink to &quot;27、token 保存在哪里？&quot;">​</a></h2><p>token可以保存的地方有很多，例如 localStorage、cookie、vuex、sessionStorage等地方。</p><p>比较推荐的是 localStorage、cookie ，可以很方便地实现免密登录、记住密码等功能</p><h2 id="_28、自己封装过组件吗-介绍一下常用的组件-待补充" tabindex="-1">28、自己封装过组件吗？介绍一下常用的组件（待补充） <a class="header-anchor" href="#_28、自己封装过组件吗-介绍一下常用的组件-待补充" aria-label="Permalink to &quot;28、自己封装过组件吗？介绍一下常用的组件（待补充）&quot;">​</a></h2><p>在封装组件的时候，不要随便过度的去拆分封装组件，是要遵守一些原则的：</p><p>比如一个组件只负责一个特定的功能或者行为，还有数据是否是动态，就是从后台接口拿到数据进行渲染， 还有就是是否多个页面都可以使用到的，可复用性比较高，满足这些条件的都应该封装成组件，这样的代码 写出来它的结构会比较清晰，容易维护</p><p>例如，我之前的做过的一个项目，是 xx 管理平台，它的首页里面有一个搜索框，商品轮播图，因为这部分数据 是可以在后台管理平台里面进行修改，因此把这个轮播图就封装成一个组件，后面如果要修改一些内容或者样式 也会比较方便，父组件请求回来的数据，通过 props 传递给子组件使用，还有设置了一些方法，比如是否自动播放、 播放间隔时间是多少等内容，都可以通过父组件传值来决定</p><p>组件封装的时候要尽量考虑的全面一点，可以使用插槽预留一些位置，方便使用者动态地去插入内容，让这个 组件更加灵活，满足更多自定义的场景需求。</p><ol><li><p>组件的作用</p></li><li><p>封装的步骤</p></li><li><p>如果有传参</p></li></ol><h2 id="_29、打包压缩时-dist-文件过大怎么处理" tabindex="-1">29、打包压缩时，dist 文件过大怎么处理 <a class="header-anchor" href="#_29、打包压缩时-dist-文件过大怎么处理" aria-label="Permalink to &quot;29、打包压缩时，dist 文件过大怎么处理&quot;">​</a></h2><p>可以对项目做一下优化处理：</p><ol><li><p>dist打包生成的文件中有 .map 文件，可以在 vue.config.js 文件中，配置 productionSourceMap:false，表示不生成 map</p></li><li><p>多使用组件和路由的懒加载，按需引入</p></li><li><p>第三方包通过 script 标签，CDN 的方式引入</p></li><li><p>对于文件和图片进行压缩，可以安装压缩插件：compression-webpack-plugin 下载之后在 vue.config.js 中进行配置：组件不打包、分割代码、超过一定大小的文件进行压缩等选项</p></li></ol><h2 id="_30、vue-源码" tabindex="-1">30、vue 源码 <a class="header-anchor" href="#_30、vue-源码" aria-label="Permalink to &quot;30、vue 源码&quot;">​</a></h2><p>在 node_modules/vue/src 目录中存放这vue的源码，其中有个 core 目录，里面包含了 vue 的核心代码，包括内置组件、全局 API 封装、Vue实例化、观察者、虚拟DOM 以及工具函数等，</p><h2 id="_31、vue-是怎么渲染模板的" tabindex="-1">31、vue 是怎么渲染模板的？ <a class="header-anchor" href="#_31、vue-是怎么渲染模板的" aria-label="Permalink to &quot;31、vue 是怎么渲染模板的？&quot;">​</a></h2><p>在vue源码的 vue/src/core/instance/init.js 文件，是模板渲染的起点，主要逻辑是：</p><ol><li><p>先检查是否有 el 属性，有就调用 vm.$mount 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM，无论怎么渲染， 最终都会生成 Render 函数，在 instance/lifecycle.js，通过 Watcher 的绑定，每当数据发生变化时， 会执行 _update 方法，此时会执行 vm._render()方法，在这个方法里，会执行我们的 Render 函数， 得到一个 VNode 对象，而这个 VNode 就是 vue2.x 中的虚拟(Virtual) DOM</p></li><li><p>Virtual DOM 的基本思路分为两步：</p></li></ol><ul><li><p>使用 JS 模拟DOM树： VNode 的数据结构中还有 VNodeData、VNodeDirective、VNodeComponentOptions，这些数据结构 都是对DOM节点的一些描述</p></li><li><p>DOM模型树通过 diff 算法查找差异，将差异转为真正的DOM节点：这里是通过在源码src/core/vdom/patch.js 文件中的 一个 patch(oldVode, newVode, hydrating) 方法来完成，patch 方法接收三个参数， 旧的VNode、新的VNode以及一个 hydrating 表示是否使用 服务端渲染的DOM元素</p></li></ul><p>总结一下：</p><ol><li><p>先 new Vue，执行初始化</p></li><li><p>挂载 $mount 方法，通过自定义 Render 方法、template文件、el 等生成 Render 函数</p></li><li><p>通过 Watcher 监听数据的变化，当数据发生变化时，Render 函数执行生成 VNode 对象</p></li><li><p>通过 patch 方法，对比新旧的VNode，然后运行diff算法，来进行增删改真正的DOM元素，使得页面发生变化</p></li></ol><h2 id="_32、diff-算法" tabindex="-1">32、diff 算法 <a class="header-anchor" href="#_32、diff-算法" aria-label="Permalink to &quot;32、diff 算法&quot;">​</a></h2><p>在我们前端程序中，操作数据要比直接操作DOM结构要快，所以把DOM结构转换为一个数据对象，也就是虚拟DOM， 对它进行增删改等操作，然后再统一转换为真实DOM，提高DOM操作的效率，因此需要对比新旧 DOM 变化，就会用到这个diff算法：</p><p>diff算法的核心主要是：</p><ol><li><p>h() 函数，作用是把DOM结构转化为虚拟DOM，有三个参数：标签名、对象、数据（字符串或者数组） h()函数可以根据不同的数据类型执行不同的操作，如果是基本数据类型，h()函数会把它放到节点对象的text属性中，表示文本内容 如果是数组类型对象，h()函数会遍历数组，将其中的每个元素当成子节点放到节点对象 children 数组中</p></li><li><p>还有一个 patch 函数，它会将旧的真实DOM元素转换成对应的虚拟DOM节点，然后将新旧虚拟DOM进行对比， 通过一系列替换节点、移动、插入或者删除以及更新属性等操作，将新的虚拟DOM转换成真实DOM，页面就会更新了</p></li></ol><p>总结一下diff算法的主要逻辑是：</p><p>diff算法是用来对比新的和旧的虚拟DOM树，它会维护两个指针，一个指向旧的虚拟DOM、一个指向新的虚拟DOM，在对比时：</p><ol><li><p>首先会对比 节点本身，如果不是同一个节点，就直接删除旧的节点创建新的节点进行替换</p></li><li><p>如果是相同的节点，就递归对子节点比较，然后再比较子节点时，diff算法会尽可能重复利用已经存在的节点，减少DOM操作次数</p></li><li><p>如果新虚拟DOM中某个节点在旧的DOM中也存在，diff算法会把它移动到正确的位置，而不是进行删除和插入新节点</p></li><li><p>如果旧的虚拟DOM中某个节点在新的中不存在，就会删掉它</p></li></ol><p>然后在这个过程中，DOM节点上绑定的 key 起到一个很大的作用，它可以让diff算法进行对比时更准确、更快地完成遍历</p><p>更准确是指在复用节点时可以避免使用了错误的旧节点，更快是利用key的唯一性生成map对象， 直接获取对应节点，而不用等遍历一遍才拿到对应节点</p><p>(渡一) 当组件创建和更新时，vue均会执行内部的update函数，该函数使用render函数生成的虚拟dom树，将新旧两树进行对比， 找到差异点，最终更新到真实dom</p><p>对比差异的过程叫diff，vue在内部通过一个叫patch的函数完成该过程</p><p>在对比时，vue采用深度优先、同层比较的方式进行比对在判断两个节点是否相同时，vue是通过虚拟节点的key和tag来进行判断的</p><p>具体来说，首先对根节点进行对比，如果相同则将旧节点关联的真实dom的引用挂到新节点上，然后根据需要更新属性到真实dom， 然后再对比其子节点数组;如果不相同，则按照新节点的信息递归创建所有真实dom，同时挂到对应虚拟节点上，然后移除掉旧的dom。</p><p>在对比其子节点数组时，vue对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比， 这样做的目的是尽量复用真实dom，尽量少的销毁和创建真实dom。如果发现相同，则进入和根节点一样的对比流程， 如果发现不同，则移动真实dom到合适的位置。这样一直递归的遍历下去，直到整棵树完成对比。</p><p>diff的时机：</p><h2 id="_33、scoped-原理" tabindex="-1">33、scoped 原理 <a class="header-anchor" href="#_33、scoped-原理" aria-label="Permalink to &quot;33、scoped 原理&quot;">​</a></h2><p>vue中的scoped属性可以隔离组件样式，它主要是通过 PostCss 这个库实现的，PostCss 在vue项目编译的时候， 给组件中所有的DOM添加一个唯一的动态属性，也就是类似 data-v-xxx 的这样一个随机字符串，然后再给所有的css选择器 加上这个对应的属性选择器，来选择组件中的DOM，这样就可以让组件的样式只作用在对应组件的内部DOM元素</p><h2 id="_34、echarts-常用配置" tabindex="-1">34、Echarts 常用配置 <a class="header-anchor" href="#_34、echarts-常用配置" aria-label="Permalink to &quot;34、Echarts 常用配置&quot;">​</a></h2><p>echarts是一个著名的图表库，我们下载引入之后，要进行配置来使用，首先要创建一个 DOM 元素作为容器</p><p>获取 DOM 元素来初始化 echarts 实例，然后在一个 option 对象里面进行配置，可以配置很多东西， 比如 title 标题组件，可以配置 show、text 是否显示，显示文本等</p><p>toolbox 工具栏，可以配置导出图片、数据视图、切换、缩放、是否显示等等</p><p>然后还有 图表的类型 type，颜色color、位置、边框、大小、图表纵坐标和横坐标的数据等</p><p>最后使用 myEcharts.setOption(option) 方法传入配置的options对象，来绘制整个图表</p><h2 id="_35、百度地图" tabindex="-1">35、百度地图 <a class="header-anchor" href="#_35、百度地图" aria-label="Permalink to &quot;35、百度地图&quot;">​</a></h2><ol><li><p>首先要去申请百度地图的密钥，引入地图数据</p></li><li><p>在项目中引入地图数据脚本</p></li><li><p>在webpack中配置地图数据脚本的基本信息，封装为对象结构---地图对象</p></li><li><p>在项目中引入这个地图对象，并进行配置：</p><ul><li><p>导入地图，CDN导入即可，</p></li><li><p>设置地图的容器div，设置缩放比例，是否开启拖拽等</p></li><li><p>还有设置坐标点，添加覆盖物（行政区，景点介绍）</p></li><li><p>限定地图显示范围（需要四个坐标点）</p></li></ul></li></ol><h2 id="_36、前端工程化" tabindex="-1">36、前端工程化 <a class="header-anchor" href="#_36、前端工程化" aria-label="Permalink to &quot;36、前端工程化&quot;">​</a></h2><p>web业务日益复杂化和多元化，前端开发从 WebPage 模式为主转变为 WebApp 模式为主，前端工程化是使用软件工程的技术和方法， 对前端的开发流程、技术、工具、经验等进行规范化、标准化，其主要目的为了提高效率、降低成本</p><p>主要应该从模块化、组件化、规范化、自动化四个方面思考。</p><ol><li><p>模块化：将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载，具体有：</p><ul><li><p>js模块化：模块化加载方案，如 CommonJS、AMD、CMD</p></li><li><p>css模块化：sass、less、stylus等实现了css的文件拆分，选择器全局污染问题没解决 从工具层面，创造出<code>Shadow DOM</code>、<code>CSS in JS</code> 和 <code>CSS Modules</code><code>Shadow DOM</code>解决全局污染问题，目前很多浏览器不兼容， <code>CSS in JS</code>是彻底抛弃css，使用js或json来写样式，处理伪类等问题比较困难 <code>CSS Modules</code>仍然使用css，只是让js来管理依赖，目前来看是最好的解决方案</p></li><li><p>资源模块化：</p></li></ul></li><li><p>组件化：每个组件会包含模板（HTML）+样式（CSS）+逻辑（JS），是一个功能完备的结构单元</p></li><li><p>规范化：目录结构的命名规范，比如 js/css/img 等文件规范，还有接口规范、文档规范等</p></li><li><p>自动化：对各种资源的自动合并，比如图标合并、持续集成、自动化构建、部署、测试等</p></li></ol><h2 id="_37、支付功能怎么做" tabindex="-1">37、支付功能怎么做 <a class="header-anchor" href="#_37、支付功能怎么做" aria-label="Permalink to &quot;37、支付功能怎么做&quot;">​</a></h2><p>支付功能是通过调用微信、支付宝等支付平台的API接口完成的，要去对应的平台注册账号，得到授权才能调用api接口</p><ol><li>支付宝支付的话，我们前端一般就是有一个商品订单页面，然后调用后台的支付接口，返回订单号、支付金额等信息</li></ol><p>然后我们前端就把订单号、金额等参数展示到用户面前，用户确定支付，调用预支付接口，然后跳到支付宝支付页面</p><ol start="2"><li>还有微信支付的话，后台一般会返回一个二维码地址，我们前端就需要安装插件 npm install qrcodejs2 ,调用这个库</li></ol><p>地址渲染成二维码放到页面上，用户扫描二维码进行支付，后台就会收到支付成功的结果，我们前端呢就需要去做一个轮询，</p><p>不断地请求接口来查询是否支付完成，可以在生命周期里面来做轮询，收到支付成功结果之后跳出页面，销毁这些事件</p><h2 id="_38、vue3的新特性" tabindex="-1">38、vue3的新特性 <a class="header-anchor" href="#_38、vue3的新特性" aria-label="Permalink to &quot;38、vue3的新特性&quot;">​</a></h2><p>首先是这个双向绑定原理的优化，由 ES5 的 Object.defineProperty 改成了 ES6 的 Proxy 代理，速度更快了，性能会更好</p><p>还有 Vdom（虚拟DOM） 的重写、对模板编译进行了优化，提高了性能和可维护性</p><p>支持这个碎片化，template模板下不再限定一个根标签了，对 ts 语言提升支持，提供更好的类型检查</p><p>还有支持这个 tree-shaking ，去除无用代码和模块，使得代码体积更小，</p><p>最后还有一个，实现用 DOM 方式进行 WebGL 编程</p></div></div></main><footer class="VPDocFooter" data-v-c4b0d3cf data-v-face870a><!--[--><!--]--><!----><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter" data-v-b2cf3e0b data-v-f7fc41f4><div class="container" data-v-f7fc41f4><p class="message" data-v-f7fc41f4>Released under the MIT License.</p><p class="copyright" data-v-f7fc41f4>Copyright © 2023-present janglong</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"25e5e21a\",\"guide_plus.md\":\"26fc1155\",\"guide_guide.md\":\"dda4a27c\",\"vuenote_vue3_index.md\":\"c1d18521\",\"moment_src_工具类.md\":\"d1f4e2ab\",\"others_uniapp.md\":\"f0ef70ca\",\"plus_事件循环.md\":\"a2dd4724\",\"moment_src_面试流程.md\":\"12439457\",\"plus_浏览器工作原理.md\":\"bdcc2f6c\",\"others_ts.md\":\"be068da9\",\"vuenote_vue2_note_01.md\":\"152555bd\",\"others_git.md\":\"4a43cc4b\",\"moment_src_必背题_js.md\":\"437c773d\",\"moment_src_html和css相关.md\":\"4aa3b568\",\"plus_css属性计算过程.md\":\"8efae258\",\"plus_css包含块.md\":\"1f4404e7\",\"moment_src_必背题_项目场景.md\":\"e99b63a2\",\"moment_src_必背题_vue.md\":\"bad37d34\",\"vuenote_vue2_index.md\":\"4f59fc68\",\"moment_src_2023前端面试题.md\":\"7e62e12e\"}")
__VP_SITE_DATA__ = JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"博客\",\"description\":\"阿龙的学习笔记、个人博客网站\",\"base\":\"/\",\"head\":[],\"appearance\":true,\"themeConfig\":{\"logo\":\"/favicon.ico\",\"siteTitle\":\"阿龙的网站\",\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/hj-long\"}],\"nav\":[{\"text\":\"首页\",\"link\":\"/\"},{\"text\":\"指南\",\"link\":\"/guide/guide\"},{\"text\":\"面试题\",\"items\":[{\"text\":\"vue相关\",\"link\":\"/moment_src/必背题_vue.md\"}]},{\"text\":\"前端基础\",\"items\":[{\"text\":\"vue2\",\"link\":\"/vueNote/vue2/\"},{\"text\":\"vue3\",\"link\":\"/vueNote/vue3/\"},{\"text\":\"uniapp\",\"link\":\"/others/uniapp\"},{\"text\":\"javaScript\",\"link\":\"/others/js\"},{\"text\":\"typeScript\",\"link\":\"/others/ts\"}]},{\"text\":\"进阶知识\",\"items\":[{\"text\":\"浏览器\",\"link\":\"/guide/plus\"}]}],\"sidebar\":{\"Vue\":[{\"text\":\"Vue框架\",\"collapsible\":true,\"collapsed\":false,\"items\":[{\"text\":\"概况\",\"link\":\"/vueNote/vue2/note_01.md\"},{\"text\":\"入门\",\"link\":\"/vueNote/vue2/\"},{\"text\":\"进阶\",\"link\":\"/vueNote/vue2/\"}]}]},\"footer\":{\"message\":\"Released under the MIT License.\",\"copyright\":\"Copyright © 2023-present janglong\"}},\"locales\":{},\"scrollOffset\":90,\"cleanUrls\":false}")</script>
    
  </body>
</html>